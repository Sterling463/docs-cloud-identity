<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section [
<!ENTITY % common SYSTEM "../../common/common.ent">
%common;
]>
<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:db="http://docbook.org/ns/docbook" 
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="Overview-Keystone-API-d1e62">
 
<title>General API Information</title>
    
	<para>
		The authentication service allows clients to obtain
		tokens that can be used to access cloud services such as those
		provided by Rackspace and OpenStack.</para>
	
	<para>The authentication service API is implemented using a ReSTful
			web service interface. All requests to authenticate and
			operate against the authentication service should be 
			performed using SSL over HTTP (HTTPS) on TCP port
			443.</para>
	
	<!--Note the Admin concepts section contains a workflow diagram not included in Dev guide.  
		That's why the xi:include content is conditional.-->
	<xi:include href="identity-concepts-admin.xml"/>
	<xi:include href="section-identity-concepts.xml"/>
    <xi:include href="../shared/section_gs_curl_how_curl_works.xml"/>
	<xi:include href="section-ReqRespTypes.xml"/>
	<xi:include href="section-authReqResp_annotated.xml"/>
	<xi:include href="section-service-catalog.xml"/>
    <xi:include href="section-identity-multfactorauth.xml"/>
	<xi:include href="section-roles.xml"/>
	<section xml:id="Content_Compression-d1e262">
	  <title>Content Compression</title>
	  <para>Request and response body data can be encoded with gzip
			compression in order to accelerate interactive performance
			of API calls and responses. Encoding is controlled using the
				<code>Accept-Encoding</code> header on the request
			from the client and indicated by the
				<code>Content-Encoding</code> header in the server
			response. By default, encoding is disabled.</para>
	  <table rules="all">
		<caption>Compression Headers</caption>
		<thead>
		  <tr>
			<td>Header Type</td>
			<td>Name</td>
			<td>Value</td>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td>HTTP/1.1 Request</td>
		  	<td><code>Accept-Encoding</code></td>
			<td>gzip</td>
		  </tr>
		  <tr>
			<td>HTTP/1.1 Response</td>
		  	<td><code>Content-Encoding</code></td>
			<td>gzip</td>
		  </tr>
		</tbody>
	  </table>
	</section>
	<!-- Commenting out because this feature does not seem to work properly 
	
	<section xml:id="Paginated_Collections-d1e664">
		<title>Paginated Collections</title>
		<para>To reduce load on the service, list operations return a maximum number of items at a time.
			The maximum number of items returned is determined by the Identity provider.</para>
		<para>To navigate the collection, you can set the <parameter>limit</parameter> and <parameter>marker</parameter>
			parameters in the URI request. For example:</para>
		<programlisting>?<parameter>limit</parameter>=100&amp;<parameter>marker</parameter>=1234</programlisting>
		<para>The <parameter>marker</parameter> parameter is the ID of the last item in the previous list.
			Items are sorted by update time in descending order. When an update time is not
			available, the items are sorted by ID. A marker with an ID that is not valid returns an
			itemNotFound (<errorcode>404</errorcode>) fault. </para>
		<para>The <parameter>limit</parameter> parameter sets the page size. If the client specifies a
			<parameter>limit</parameter> value that is greater than the supported limit, an overLimit
			(<errorcode>413</errorcode>) fault might be thrown. </para>
		<para>Both parameters are optional. </para>
		<note>
			<para>Paginated collections never return itemNotFound (<errorcode>404</errorcode>) faults when
				the collection is empty &mdash; clients should be prepared to handle an empty
				collection. </para>
		</note>
		<para>Paginated collections contain "next" and "previous"
			links. The first page in the list will not contain a
			"previous" link; similarly, the last page in the list will
			not contain a "next" link. 
		</para>
		<para>The following examples show pages in a collection of Identity role definitions. </para>
		<para>To get the first page, issue a &GET; request to the following endpoint and set the
				<parameter>limit</parameter> parameter to the page size of a single item:
			<programlisting>http://identity.api.rackspacecloud.com/OS-KSADM/roles?limit=1</programlisting></para>
		<para>Subsequent links honor the initial page size. A client can follow links to traverse a paginated collection. </para>
		<?hard-pagebreak?>
		<para> In the following examples, a Roles collection is returned as three linked pages. The first page is
			retrieved via a &GET; to
				<code>http://identity.api.openstack.org/v2.0/1234/roles?limit=1</code>; the second
			page is retrieved by following the "next" link from the first page; the third page is
			retrieved by following the "next" link from the second page. </para>	
		<para>	
			The <parameter>limit</parameter>
			parameter sets the page size;
			<parameter>limit=1</parameter> returns one item on the first page. Subsequent
			"next" and "previous" links honor the initial page
			size. Thus, a client may follow links to traverse a
			paginated collection without having to input the
				<parameter>marker</parameter> parameter. </para>
		
		<example>
			<title>Roles Collection, First Page: JSON</title>
			<programlisting language="javascript"><xi:include href="../../common/samples/auth-getRoleid-pagination-header-1.json" parse="text"/></programlisting>
		</example>
		
		<example>
			<title>Roles Collection, Second Page: JSON</title>
			<programlisting language="javascript"><xi:include href="../../common/samples/auth-getRoleid-pagination-header-2.json" parse="text"/></programlisting>
		</example>
		<example>
			<title>Roles Collection, Last Page: JSON</title>
			<programlisting language="javascript"><xi:include href="../../common/samples/auth-getRoleid-pagination-header-3.json" parse="text"/></programlisting>
		</example>
		
	</section>
	-->
	<section xml:id="Versions-d1e472">
		<title>Contract versions</title>
		<para>The contract version denotes the data model and behavior that the API supports.
			The Identity API uses a URI version scheme.</para>
		<important>
			<para>The Rackspace implementation of the OpenStack Keystone Identity
				Service v2.0 does not
				yet support MIME-type version. </para>
		</important>
		<para> All client requests to the API must specify the target
			version identifier in the first element of the URI path.
			For example, v2.0 is the target version in this enddpoint
			URI: <programlisting>&ENDPOINT-IdentityVersion;</programlisting>The
			only access available without the target version are to
			check for the GET version API request that returns
			available API versions supported at the specified
			endpoint. </para>

<!-- Information about MIME type support not included in the production output. -->

		<para security="writeronly">
			The authentication service API uses two version schemes, one based on the URI 
			and the other based on MIME type.
			<annotation>
				<remark>MIME-type version support has not been implemented in v2.0;
					meanwhile, using URI-only text borrowed from Auth
					1.1. </remark>
			</annotation>
			<itemizedlist>
				<listitem>
					<para>			
						In the URI version scheme, the first
						element of the path contains the target version
						identifier. For example, in <code>https://identity.api.openstack.org/
						v2.0/&hellip;</code>, the target version is identified as <code>v2.0</code>. 
					</para>
				</listitem>	
				<listitem>
					<para>
						The MIME-type version scheme uses
						HTTP content negotiation where the <code>Accept</code>
						or <code>Content-Type</code> header contains a MIME
						type that includes the version ID as a parameter.
						For example, in <code>
						application/vnd.openstack.identity+xml;version=1.1</code>, 
						the target version is identified as <code>1.1</code>. 
						A version MIME type is always linked to a base MIME type
						such as <code>application/xml</code> or <code>application/json</code>. 
					</para>
				</listitem>
			</itemizedlist>
			If conflicting
			versions are specified using both a MIME type and a
			URI, the URI takes precedence.
		</para>
		<example security="writeronly">
			<title>Request with MIME-Type version scheme</title>
			<literallayout class="monospaced">
GET /tenants HTTP/1.1
Host: identity.api.rackspacecloud.com
Accept: application/vnd.openstack.identity+xml;version=1.1
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
			</literallayout>
		</example>
<para>The following example shows an XML request that uses 
			URI versioning.
		<example>
			<title>Request with URI version scheme</title>
			<literallayout class="monospaced">
GET /v2.0/tenants HTTP/1.1
Host: identity.api.rackspacecloud.com
Accept: application/xml
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
			</literallayout>
		</example>
</para>


		<para>The URI scheme for API contracts supports the following development practices: <itemizedlist>
				<listitem>
					<para>New features and functionality that do not break API compatibility are
						introduced in the current version of the API as <link
							linkend="Extensions-d1e688">extensions</link>. The URI version stays the
						same. For example, the &CIS; is developing the RAX-AUTH extension to develop
						new services and resources to support the Rackspace implementation of
						OpenStack Keystone v2.0.</para>
				</listitem>
				<listitem>
					<para> Service providers must change the API contract version anytime they
						introduce or deprecate features or functionality that make the API
						incompatible with previously released versions. When the version changes,
						the target version in the URI is updated, from v2.0 to v3.0 for
						example.</para>
				</listitem>
				<listitem>
					<para>When new API versions are released, older versions are
							<code>DEPRECATED</code>. Because a service endpoint can host multiple
						API versions, service providers can work with developers and partners to
						ensure adequate time to migrate to the new version before removing the
						deprecated version from service.</para>
				</listitem>
			</itemizedlist>
		</para>
<!--		
		<para security="writeronly">
			The authentication service API uses two version schemes, one based on the URI 
			and the other based on MIME type.
			<annotation>
				<remark>MIME-type version support has not been implemented in v2.0;
					meanwhile, using URI-only text borrowed from Auth
					1.1. </remark>
			</annotation>
			<itemizedlist>
				<listitem>
					<para>			
						In the URI version scheme, the first
						element of the path contains the target version
						identifier. For example, in <code>https://identity.api.openstack.org/
						v2.0/&hellip;</code>, the target version is identified as <code>v2.0</code>. 
					</para>
				</listitem>	
				<listitem>
					<para>
						The MIME-type version scheme uses
						HTTP content negotiation where the <code>Accept</code>
						or <code>Content-Type</code> header contains a MIME
						type that includes the version ID as a parameter.
						For example, in <code>
						application/vnd.openstack.identity+xml;version=1.1</code>, 
						the target version is identified as <code>1.1</code>. 
						A version MIME type is always linked to a base MIME type
						such as <code>application/xml</code> or <code>application/json</code>. 
					</para>
				</listitem>
			</itemizedlist>
			If conflicting
			versions are specified using both a MIME type and a
			URI, the URI takes precedence.
		</para>
		<example security="writeronly">
			<title>Request with MIME-Type version scheme</title>
			<literallayout class="monospaced">
GET /tenants HTTP/1.1
Host: identity.api.rackspacecloud.com
Accept: application/vnd.openstack.identity+xml;version=1.1
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
			</literallayout>
		</example>
		
		<note security="writeronly">
			<para>
				The MIME-type version approach supports the
				creation of permanent links, because the version
				scheme is not specified in the URI path. For example, 
				<code>https://api.identity.openstack.org/tenants/12234</code>
				identifies a list of tenants associated with <code>12234</code> but does not identify a version.
			</para>
		</note>
		<para security="writeronly">
			If a request is made with no version specified, then a multiple-choices
			response (<returnvalue>300</returnvalue>) will follow,
			providing links and MIME types for available versions.
		</para>
		<example security="writeronly">
			<title>Multiple Choices Response: XML</title>
			<programlisting language="xml">
<xi:include href="../samples/choices.xml" parse="text"/>
			</programlisting>
		</example>
		<example security="writeronly">
			<title>Multiple Choices Response: JSON</title>
			<programlisting language="javascript"><xi:include href="../samples/choices.json" parse="text"/></programlisting>
		</example>  -->
		
		<para>You can programmatically determine available API versions by performing a &GET; on the root
			URL returned from the authentication system. In the root URL, the version and everything
			to the right of it is truncated. An Atom representation of the version's resources is
			supported when issuing a request with the <code>Accept</code> header containing
				<code>application/atom+xml</code> or by adding <code>.atom</code> to the request
			URI. This allows standard Atom clients to track version changes. </para>
		<example>
			<title>Versions List Request</title>
			<literallayout class="monospaced">
GET HTTP/1.1
Host: identity.api.rackspacecloud.com
			</literallayout>
		</example>
		<simpara>&CODES; <returnvalue>200</returnvalue>, <returnvalue>203</returnvalue></simpara>
		<simpara>&ERROR_CODES; badRequest
		(<errorcode>400</errorcode>), identityFault
		(<errorcode>500</errorcode>),
		serviceUnavailable(<errorcode>503</errorcode>)</simpara>
		&NO_REQUEST;
		<example>
			<title>Versions List Response: XML</title>
			<programlisting language="xml">
<xi:include href="../../common/samples/versions.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Versions List Response: Atom</title>
			<programlisting language="xml">
<xi:include href="../../common/samples/versions-atom.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Versions List Response: JSON</title>
			<programlisting language="javascript"><xi:include href="../../common/samples/versions.json" parse="text"/></programlisting>
		</example>
		<para>You can obtain additional detailed information about a specific version by performing a
			&GET; on the base version URL. For example,
				<code>https://identity.api.rackspacecloud.com/v2.0/</code> is a base version URL, in
			which <code>v2.0</code> is the initial version of the API. All version request URLs end
			with a trailing slash (/). If the slash is omitted, the server might respond with a
				<returnvalue>302</returnvalue> redirection request. You can add format extensions
			after the trailing slash. For example, <code>&ENDPOINT-IdentityVersion;.xml</code> includes
				<code>.xml</code> as a format extension. Note that this is a special case that does
			not hold true for other API requests. In general, requests such as
				<code>/tenants.xml</code> and <code>/tenants/.xml</code> are handled equivalently. </para>
		<example>
			<title>Version Details Request</title>
			<literallayout class="monospaced">
GET HTTP/1.1
Host: identity.api.rackspacecloud.com/v1.0/
			</literallayout>
		</example>
		<simpara>&CODES; <returnvalue>200</returnvalue>, <returnvalue>203</returnvalue></simpara>
		<simpara>&ERROR_CODES; badRequest
		(<errorcode>400</errorcode>), identityFault
		(<errorcode>500</errorcode>),
		serviceUnavailable(<errorcode>503</errorcode>)</simpara>
		&NO_REQUEST;
		<example>
			<title>Version Details Response: XML</title>
			<programlisting language="xml">
<xi:include href="../../common/samples/version.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Version Details Response: Atom</title>
			<programlisting language="xml">
<xi:include href="../../common/samples/version-atom.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Version details response: JSON</title>
			<programlisting language="javascript"><xi:include href="../../common/samples/version.json" parse="text"/></programlisting>
		</example>
		<para>
			The detailed version response contains pointers to
			both a human-readable and a machine-processable
			description of the API service. The machine-processable description is written in the Web
			Application Description Language (WADL).
		</para>
		<note>
			<para>If there is a discrepancy between the two specifications, the WADL is
			authoritative as it contains the most accurate and up-to-date description of the
			API service. </para>
		</note>
	</section>
	<xi:include href="section-extensions.xml"/>
	<xi:include href="section-namespaces.xml"/>
	<section condition="admin" xml:id="Limits-d1e909">
		<title>Limits</title>
		<para>Rate limits control the frequency at which the user can issue specific API requests. Limits
			can be applied to any of the following entities, depending on the data available in the
			operation request.<itemizedlist>
				<listitem>
					<para>IP address submitting the request</para>
				</listitem>
				<listitem>
					<para>user name</para>
				</listitem>
				<listitem>
					<para>token in the <code>X-Auth-Token</code>
					</para>
				</listitem>
			</itemizedlist>
		</para>
		
		<para>If a requester exceeds the rate limit, the request is rejected with a <errorcode>413</errorcode>
			<code>overLimit</code> error. Typically, the request can be resubmitted in a few seconds. 
			If the client requests continue to be rejected, check the client, process, or application 
			code to verify that API access is managed effectively.</para>
		
		<para>&CIS; has its own rate limiting settings, and so does each node. If an application node is
			restarted, the last properties set for any of the &CIS; versions are loaded to all
			nodes.</para>
		
		<para>&CIS; administrators and developers manage the rate limit settings and configuration, 
			but Identity administrators can use the Rate limit API operations to get information about 
			rate limit configuration and events to troubleshoot problems.</para>
		
		<tip condition="admin">
			<para> You can learn about rate limiting operations in <link xlink:href="Ratelimiting_Calls.html">Rate Limits</link>.</para>
		</tip>
	</section>
	<section xml:id="Faults-d1e908">
		<title>Faults</title>
		<para>
			When an error occurs, the system returns an HTTP error response code denoting the type of error. The system 
			returns additional information about the fault in the body of the response. 
		</para>
		<para>
			The following table lists possible fault types along with their associated error codes. 
		</para>
		<table rules="all">
			<caption>Fault Types</caption>
			<thead>
				<tr>
					<td>Fault Element</td>
					<td>Associated Error Codes</td>
					<td>Expected in All Requests?</td>
				</tr>
			</thead>
			<tbody>
				<tr align="left">
					<td>serviceFault</td>
					<td>500</td>
					<td> Yes</td>
				</tr>
				<tr>
					<td>serviceUnavailable</td>
					<td>503</td>
					<td/>
				</tr>
				<tr align="left">
					<td>badRequest</td>
					<td>400</td>
					<td> Yes</td>
				</tr>
				<tr align="left">
					<td>unauthorized</td>
					<td>401</td>
					<td> Yes</td>
				</tr>
				<tr align="left">
					<td><link linkend="Limits-d1e909"
							>overLimit</link></td>
					<td>413</td>
					<td> Yes</td>
				</tr>
				<tr align="left">
					<td>userDisabled</td>
					<td>403</td>
					<td/>
				</tr>
				<tr align="left">
					<td>forbidden</td>
					<td>403</td>
					<td/>
				</tr>
				<tr align="left">
					<td>itemNotFound</td>
					<td>404</td>
					<td/>
				</tr>
				<tr align="left">
					<td>tenantConflict</td>
					<td>409</td>
					<td/>
				</tr>
			</tbody>
		</table>
		<para> The root element of the fault can change depending on the type of error. From an XML schema
			perspective, all API faults are extensions of the base fault type,
				<type>identityFault</type>. When working with a system that binds XML to actual
			classes, use <type>identityFault</type> as a catch-all if there is no interest in
			distinguishing between individual fault types; for example, you might need to do this if
			you are working with JAXB. </para>
  		<para> The error code is returned in the body of the response. The message section returns a
			human-readable message. The details section is optional and may contain useful
			information for tracking down an error. For example, a stack trace might be provided. </para>
  		<para> 
  			The following are examples of an <code>itemNotFound</code> error. 
  		</para>
		<example>
			<title>Item Not Found Fault: XML</title>
			<programlisting language="xml">
				<xi:include href="../../common/samples/item_not_found.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Item Not Found Fault: JSON</title>
			<programlisting language="javascript">
				<xi:include href="../../common/samples/item_not_found.json" parse="text"/>
			</programlisting>
		</example>
	</section>
    </chapter>
