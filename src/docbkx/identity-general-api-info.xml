<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter [<!-- Some useful entities borrowed from HTML -->
<!ENTITY ndash  "&#x2013;">
<!ENTITY mdash  "&#x2014;">
<!ENTITY hellip "&#x2026;">

<!-- Useful for describing APIs -->
<!ENTITY GET    '<command xmlns="http://docbook.org/ns/docbook">GET</command>'>
<!ENTITY PUT    '<command xmlns="http://docbook.org/ns/docbook">PUT</command>'>
<!ENTITY POST   '<command xmlns="http://docbook.org/ns/docbook">POST</command>'>
<!ENTITY DELETE '<command xmlns="http://docbook.org/ns/docbook">DELETE</command>'>
<!ENTITY HEAD    '<command xmlns="http://docbook.org/ns/docbook">HEAD</command>'>


<!ENTITY CHECK  '<inlinemediaobject xmlns="http://docbook.org/ns/docbook">
<imageobject>
<imagedata fileref="img/Check_mark_23x20_02.svg"
format="SVG" scale="60"/>
</imageobject>
</inlinemediaobject>'>
<!ENTITY CODES       'Normal Response Code(s):'>
<!ENTITY ERROR_CODES 'Error Response Code(s):'>
<!ENTITY NO_REQUEST '<para xmlns="http://docbook.org/ns/docbook">
This operation does not require a request body.</para>'>
<!ENTITY LONG_URI_REFHEAD '
<thead xmlns="http://docbook.org/ns/docbook">
<tr>
<td colspan="1">Verb</td>
<td colspan="4">URI</td>
<td colspan="3">Description</td>
</tr>
</thead>'>
<!ENTITY URI_REFHEAD '
<thead xmlns="http://docbook.org/ns/docbook">
<tr>
<td colspan="1">Verb</td>
<td colspan="1">URI</td>
<td colspan="4">Description</td>
</tr>
</thead>'>
]>
<chapter xmlns="http://docbook.org/ns/docbook"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
    xml:id="Overview-Keystone-API-d1e62">
         <title>General API Information</title>
        <para>The authentication service allows clients to obtain
		tokens that can be used to access cloud services such as those
		provided by Rackspace and OpenStack. </para>
		<para>The authentication service API is implemented using a ReSTful
			web service interface. All requests to authenticate and
			operate against the authentication service should be
			performed using SSL over HTTP (HTTPS) on TCP port
			443.</para>
	<section xml:id="Request_Response_Types-d1e149">
	  <title>Request/Response Types</title>
	  <para> The Keystone API supports both the JSON and XML data
			serialization formats. The request format is specified
			using the <code>Content-Type</code> header and is required
			for operations that have a request body. The response
			format can be specified in requests using either by using
			the <code>Accept</code> header or by adding an
				<code>.xml</code> or <code>.json</code> extension to
			the request URI. Note that it is possible for a response
			to be serialized using a format different from the request
			(see example below). If no response format is specified,
			JSON is the default. If conflicting formats are specified
			using both an <code>Accept</code> header and a query
			extension, the query extension takes precedence.</para>
	  <table rules="all">
		<caption>Response Types</caption>
		<thead>
		  <tr>
			<td>Format</td>
			<td>Accept Header</td>
			<td>Query Extension</td>
			<td>Default</td>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td>JSON</td>
			<td>application/json</td>
			<td>.json</td>
			<td>Yes</td>
		  </tr>
		  <tr>
			<td>XML</td>
			<td>application/xml</td>
			<td>.xml</td>
			<td>No</td>
		  </tr>
		</tbody>
	  </table>
	  <example>
		<title>Request with Headers: JSON</title>
		<programlisting language="xml">
<xi:include href="samples/samplerequestheader.txt" parse="text"/>
</programlisting>
		<programlisting language="xml">
<xi:include href="samples/auth_credentials.json" parse="text"/>
</programlisting>
	  </example>
	  <example>
		<title>Response with Headers: XML</title>
		<programlisting language="xml">
<xi:include href="samples/sampleresponseheader.txt" parse="text"/>
</programlisting>
		<programlisting language="xml">
<xi:include href="samples/auth.xml" parse="text"/>
</programlisting>
	  </example>
	</section>
	<section xml:id="Content_Compression-d1e262">
	  <title>Content Compression</title>
	  <para>Request and response body data may be encoded with gzip
			compression in order to accelerate interactive performance
			of API calls and responses. This is controlled using the
				<code>Accept-Encoding</code> header on the request
			from the client and indicated by the
				<code>Content-Encoding</code> header in the server
			response. By default, encoding is disabled.</para>
	  <table rules="all">
		<caption>Compression Headers</caption>
		<thead>
		  <tr>
			<td>Header Type</td>
			<td>Name</td>
			<td>Value</td>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td>HTTP/1.1 Request</td>
		  	<td><code>Accept-Encoding</code></td>
			<td>gzip</td>
		  </tr>
		  <tr>
			<td>HTTP/1.1 Response</td>
		  	<td><code>Content-Encoding</code></td>
			<td>gzip</td>
		  </tr>
		</tbody>
	  </table>
	</section>
	<section security="writeronly" xml:id="Paginated_Collections-d1e325">
		<title>Paginated Collections</title>
		<annotation>
			<remark>"Paginated Collections" is not yet implemented as of v2.0;
				hide it for now and reveal it when the feature is working." </remark>
		</annotation>
		<para> To reduce load on the service, list operations will return a
			maximum number of items at a time. The maximum number of
			items returned is determined by the Identity provider. To
			navigate the collection, the parameters
				<parameter>limit</parameter> and
				<parameter>marker</parameter> can be set in the URI
				(e.g.?<parameter>limit</parameter>=100&amp;<parameter>marker</parameter>=1234).
			The <parameter>marker</parameter> parameter is the ID of
			the last item in the previous list. Items are sorted by
			update time; when an update time is not available, they
			are sorted by ID. The <parameter>limit</parameter>
			parameter sets the page size. Both the
				<parameter>limit</parameter> and
				<parameter>marker</parameter> parameters are optional.
			If the client requests a <parameter>limit</parameter>
			beyond that which is supported by the deployment, an
			overLimit (<errorcode>413</errorcode>) fault may be
			thrown. A <parameter>marker</parameter> with an invalid ID
			will return an itemNotFound (<errorcode>404</errorcode>)
			fault. </para>
		<note>
			<para> Paginated collections never return itemNotFound
					(<errorcode>404</errorcode>) faults when the
				collection is empty; clients should be prepared to
				handle an empty collection. </para>
		</note>
		<para> Paginated collections contain "next" and "previous"
			Atom links. The first page in the list will not contain a
			"previous" link; similarly, the last page in the list will
			not contain a "next" link. 
		</para>
		<para>
			In the following examples, a paginated collection of tenants
			is returned as three linked pages. 
			The
			first page is retrieved via a &GET; to
			<code>http://identity.api.openstack.org/v2.0/1234/tenants?limit=1</code>;
			the second page is retrieved by following the "next" link from the first page;
			the third page is retrieved by following the "next" link from the second page.
		</para>	
		<para>	
			The <parameter>limit</parameter>
			parameter sets the page size;
			<parameter>limit=1</parameter> returns one item on the first page. Subsequent
			"next" and "previous" links honor the initial page
			size. Thus, a client may follow links to traverse a
			paginated collection without having to input the
				<parameter>marker</parameter> parameter. </para>
		<example>
			<title>Tenant Collection, First Page: XML</title>
			<programlisting language="xml">
<xi:include href="samples/tenants-1.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Tenant Collection, First Page: JSON</title>
			<programlisting language="javascript"><xi:include
			href="samples/tenants-1.json" parse="text"/></programlisting>
		</example>
		<example>
			<title>Tenant Collection, Second Page: XML</title>
			<programlisting language="xml">
<xi:include href="samples/tenants-2.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Tenant Collection, Second Page: JSON</title>
			<programlisting language="javascript"><xi:include
			href="samples/tenants-2.json" parse="text"/></programlisting>
		</example>
		<example>
			<title>Tenant Collection, Last Page: XML</title>
			<programlisting language="xml">
<xi:include href="samples/tenants-3.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Tenant Collection, Last Page: JSON</title>
			<programlisting language="javascript"><xi:include
			href="samples/tenants-3.json" parse="text"/></programlisting>
		</example>
		<para>
			In the JSON representation, paginated collections contain
			a <property>values</property> property that contains the
			items in the collections.  Links are accessed via the
			<property>links</property> property. This approach allows
			for extensibility of both the collection members and of
			the paginated collection itself. It also allows
			collections to be embedded in other objects as shown in the example 
			below. Here, a subset of groups is presented within a
			user. To continue retrieving 
			additional groups belonging to a user, a client must follow the "next" link.
		</para>
		<example>
			<title>Paginated Roles in a User: XML</title>
			<programlisting language="xml">
<xi:include href="samples/getuser-1.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Paginated Roles in an User: JSON</title>
			<programlisting language="javascript"><xi:include
			href="samples/getuser-1.json" parse="text"/></programlisting>
		</example>
	</section>
	<section xml:id="Versions-d1e472">
		<title>Versions</title>
		<para> The identity API uses a URI versioning scheme. </para>
		<important>
			<para>Rackspace's implementation of the OpenStack Keystone Identity
				Service v2.0 is currently in BETA status and does not
				yet support MIME-type versioning. </para>
		</important>
		<para>
			The first element of
			the URI path contains the target version identifier: for example, in 
			https://auth.api.rackspacecloud.com/v2.0/&hellip;, the API version is 2.0. Other than requests to query for version, 
			all requests must contain a target version. 
		</para>
	    <para>
			Any features or functionality
			changes that would necessitate a break in API compatibility will require a new
			version, which will result in the URI version being updated accordingly. When new
			API versions are released, older versions will be marked as <code>DEPRECATED</code>.
			Rackspace will work with developers and partners to ensure that there is adequate time to
			migrate to the new version before deprecated versions are discontinued. </para>
		<para security="writeronly">
			The authentication service API uses two versioning schemes, one based on the URI 
			and the other based on MIME type.
			<annotation>
				<remark>MIME-type versioning is not yet implemented in v2.0;
					meanwhile, using URI-only text borrowed from Auth
					1.1. </remark>
			</annotation>
			<itemizedlist>
				<listitem>
					<para>			
						In the URI versioning scheme, the first
						element of the path contains the target version
						identifier. For example, in <code>https://identity.api.openstack.org/
						v2.0/&hellip;</code>, the target version is identified as <code>v2.0</code>. 
					</para>
				</listitem>	
				<listitem>
					<para>
						The MIME-type versioning scheme uses
						HTTP content negotiation where the <code>Accept</code>
						or <code>Content-Type</code> header contains a MIME
						type that includes the version ID as a parameter.
						For example, in <code>
						application/vnd.openstack.identity+xml;version=1.1</code>, 
						the target version is identified as <code>1.1</code>. 
						A version MIME type is always linked to a base MIME type
						such as <code>application/xml</code> or <code>application/json</code>. 
					</para>
				</listitem>
			</itemizedlist>
			If conflicting
			versions are specified using both a MIME type and a
			URI, the URI takes precedence.
		</para>
		<example security="writeronly">
			<title>Request with MIME-Type Versioning</title>
			<literallayout class="monospaced">
GET /tenants HTTP/1.1
Host: auth.api.rackspacecloud.com
Accept: application/vnd.openstack.identity+xml;version=1.1
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
			</literallayout>
		</example>
		<example>
			<title>Request with URI Versioning</title>
			<literallayout class="monospaced">
GET /v2.0/tenants HTTP/1.1
Host: auth.api.rackspacecloud.com
Accept: application/xml
X-Auth-Token: eaaafd18-0fed-4b3a-81b4-663c99ec1cbb
			</literallayout>
		</example>
		<note security="writeronly">
			<para>
				The MIME-type versioning approach supports the
				creation of permanent links, because the version
				scheme is not specified in the URI path. For example, 
				<code>https://api.identity.openstack.org/tenants/12234</code>
				identifies a list of tenants associated with <code>12234</code> but does not identify a version.
			</para>
		</note>
		<para security="writeronly">
			If a request is made with no version specified, then a multiple-choices
			response (<returnvalue>300</returnvalue>) will follow,
			providing links and MIME types for available versions.
		</para>
		<example security="writeronly">
			<title>Multiple Choices Response: XML</title>
			<programlisting language="xml">
<xi:include href="samples/choices.xml" parse="text"/>
			</programlisting>
		</example>
		<example security="writeronly">
			<title>Multiple Choices Response: JSON</title>
			<programlisting language="javascript"><xi:include href="samples/choices.json" parse="text"/></programlisting>
		</example>
		<para> New features and functionality that do not break API
			compatibility will be introduced in the current version of
			the API as <link linkend="Extensions-d1e688"
				>extensions</link> and the URI will
			remain unchanged. Features or functionality changes that
			would disrupt in API compatibility will require a new
			version, which will result in the URI version
			being updated accordingly. When new API versions are
			released, older versions will be marked as
				<code>DEPRECATED</code>. Providers should work with
			developers and partners to ensure there is adequate time
			to migrate to the new version before deprecated versions
			are discontinued. </para>
		<para>
			You can programmatically determine
			available API versions by performing a &GET; on the
			root URL returned from the
			authentication system. In the root URL, the version and everything to the
			right of it is truncated.
			An Atom
			representation of the version's resources is supported
			when issuing a request with the <code>Accept</code>
			header containing <code>application/atom+xml</code> or by adding 
			<code>.atom</code> to the request URI.  This allows standard Atom
			clients to track version changes.
		</para>
		<example>
			<title>Versions List Request</title>
			<literallayout class="monospaced">
GET HTTP/1.1
Host: auth.api.rackspacecloud.com
			</literallayout>
		</example>
		<simpara>&CODES; <returnvalue>200</returnvalue>, <returnvalue>203</returnvalue></simpara>
		<simpara>&ERROR_CODES; badRequest
		(<errorcode>400</errorcode>), identityFault
		(<errorcode>500</errorcode>),
		serviceUnavailable(<errorcode>503</errorcode>)</simpara>
		&NO_REQUEST;
		<example>
			<title>Versions List Response: XML</title>
			<programlisting language="xml">
<xi:include href="samples/versions.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Versions List Response: Atom</title>
			<programlisting language="xml">
<xi:include href="samples/versions-atom.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Versions List Response: JSON</title>
			<programlisting language="javascript"><xi:include href="samples/versions.json" parse="text"/></programlisting>
		</example>
		<para> You can obtain additional detailed information about a
			specific version by performing a &GET; on the base version
			URL. For example,
				<code>https://auth.api.rackspacecloud.com/v1.0/</code>
			is a base version URL, in which <code>v1.0</code> is the
			initial version of the API. Version request URLs should
			always end with a trailing slash (/). If the slash is
			omitted, the server may respond with a
				<returnvalue>302</returnvalue> redirection request.
			Format extensions may be placed after the trailing slash.
			For example, <code>
				https://auth.api.rackspacecloud.com/v2.0/.xml</code>
			includes <code>.xml</code> as a format extension. Note
			that this is a special case that does not hold true for
			other API requests. In general, requests such as
				<code>/tenants.xml</code> and
				<code>/tenants/.xml</code> are handled equivalently. </para>
		<example>
			<title>Version Details Request</title>
			<literallayout class="monospaced">
GET HTTP/1.1
Host: auth.api.rackspacecloud.com/v1.0/
			</literallayout>
		</example>
		<simpara>&CODES; <returnvalue>200</returnvalue>, <returnvalue>203</returnvalue></simpara>
		<simpara>&ERROR_CODES; badRequest
		(<errorcode>400</errorcode>), identityFault
		(<errorcode>500</errorcode>),
		serviceUnavailable(<errorcode>503</errorcode>)</simpara>
		&NO_REQUEST;
		<example>
			<title>Version Details Response: XML</title>
			<programlisting language="xml">
<xi:include href="samples/version.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Version Details Response: Atom</title>
			<programlisting language="xml">
<xi:include href="samples/version-atom.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Version Details Response: JSON</title>
			<programlisting language="javascript"><xi:include href="samples/version.json" parse="text"/></programlisting>
		</example>
		<para>
			The detailed version response contains pointers to
			both a human-readable and a machine-processable
			description of the API service. The machine-processable description is written in the Web
			Application Description Language (WADL).
		</para>
		<note>
			<para>If there is a discrepancy between the two specifications, the WADL is
			authoritative as it contains the most accurate and up-to-date description of the
			API service. </para>
		</note>
	</section>
	<section xml:id="Extensions-d1e688">
		<title>Extensions</title>
		<para> The authentication service API is extensible, meaning that the API is structured so that some functions are implemented in the 
			core API and others are implemented via optional extensions to that core.
			Extensions
			serve two purposes: 
			<itemizedlist>
				<listitem>
					<para>
						Extensions allow the introduction of new
						features in the API without requiring a version change.
					</para>
				</listitem>
				<listitem>
					<para>
						Extensions allow the introduction of vendor-specific niche
						functionality.
					</para>
				</listitem>
			</itemizedlist>
			Every service provider can choose its own set of extensions to the core API.	 
			Applications can programmatically determine
			what extensions are available by performing a &GET; on the
			<code>/extensions</code> URI. Note that this is a versioned request;
			that is, an extension available in one API version may not
			be available in another, so a response is only applicable
			to a specific version. </para>
		<informaltable rules="all">
			<thead>
				<tr>
					<td colspan="1">Verb</td>
					<td colspan="2">URI</td>
					<td colspan="3">Description</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td colspan="1">&GET;</td>
					<td colspan="2">v2.0/extensions</td>
					<td colspan="3">Returns a list of available extensions</td>
				</tr>
			</tbody>
		</informaltable>
		<simpara>&CODES; <returnvalue>200</returnvalue>,
				<returnvalue>203</returnvalue></simpara>
		<simpara>&ERROR_CODES; badRequest
		(<errorcode>400</errorcode>), identityFault (<errorcode>500</errorcode>),
			serviceUnavailable(<errorcode>503</errorcode>)</simpara>
		&NO_REQUEST;
		<para>
			Each extension is identified by two unique identifiers: a
			<property>namespace</property> and an
			<property>alias</property>. 
			You can use these identifiers to associate an extension with its vendor;
			in the examples in this section, aliases prefixed <code>RAX-</code> indicate that Rackspace
			provided these extensions. 
			Additionally, an extension
			contains links to documentation in multiple formats.
		</para>
		<example>
			<title>Extensions Response: XML</title>
			<programlisting language="xml">
<xi:include href="samples/extensions.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Extensions Response: JSON</title>
			<programlisting language="javascript"><xi:include href="samples/extensions.json" parse="text"/></programlisting>
		</example>
		<para> Extensions may also be queried individually by their unique
			alias. This provides the simplest method of checking
			whether an extension is available. An unavailable
			extension will issue an itemNotFound
				(<errorcode>404</errorcode>) response. </para>
		<informaltable rules="all">
			<thead>
				<tr>
					<td colspan="1">Verb</td>
					<td colspan="2">URI</td>
					<td colspan="3">Description</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td colspan="1">&GET;</td>
					<td colspan="2">/extensions/<parameter>alias</parameter></td>
					<td colspan="3">Return details of a single extension</td>
				</tr>
			</tbody>
		</informaltable>
		<simpara>&CODES; <returnvalue>200</returnvalue>, <returnvalue>203</returnvalue></simpara>
		<simpara>&ERROR_CODES; itemNotFound
		(<errorcode>404</errorcode>), badRequest
		(<errorcode>400</errorcode>), identityFault
		(<errorcode>500</errorcode>),
		serviceUnavailable(<errorcode>503</errorcode>)</simpara>
		&NO_REQUEST;
		<example>
			<title>Extension Response: XML</title>
			<programlisting language="xml">
<xi:include href="samples/extension.xml" parse="text"/>
			</programlisting>
		</example>
		<example>
			<title>Extension Response: JSON</title>
			<programlisting language="javascript"><xi:include href="samples/extension.json" parse="text"/></programlisting>
		</example>
		<para> Extensions may define new data types, parameters, actions,
			headers, states, and resources. In XML, additional
			elements and attributes may be defined. These elements
			must be defined in the extension's namespace. In JSON, the
			alias must be used. The volumes element in the <xref
				linkend="UserEXT" xrefstyle="template: Examples %n"/>
			and <xref linkend="UserEXTJ"
				xrefstyle="select: labelnumber"/> is defined in the
				<code>RAX-META</code> namespace. Extended headers are
			always prefixed with <code>X-</code> followed by the alias
			and a dash: (<code>X-RAX-META-HEADER1</code>). Parameters
			must be prefixed with the extension alias followed by a
			colon. </para>
		<important>
			<para>
				Applications should be prepared to ignore response
				data that contains extension elements. Also,
				applications should also verify that an extension is
				available before submitting an extended request.
			</para>
		</important>
		<example xml:id="UserEXT">
			<title>Extended User Response: XML</title>
			<programlisting language="xml">
<xi:include href="samples/ext-getuser.xml" parse="text"/>
			</programlisting>
		</example>
		<example xml:id="UserEXTJ">
			<title>Extended User Response: JSON</title>
			<programlisting language="javascript"><xi:include href="samples/ext-getuser.json" parse="text"/></programlisting>
		</example>
	</section>
	<section xml:id="Faults-d1e908">
	  <title>Faults</title>
	  <para>When an error occurs, the system will return an HTTP error
			response code denoting the type of error. The system will
			also return additional information about the fault in the
			body of the response. </para>
	  <example>
		<title>Fault Response: XML</title>
		<programlisting language="xml">
<xi:include href="samples/identity_fault.xml" parse="text"/>
</programlisting>
	  </example>
	  <example>
		<title>Fault Response: JSON</title>
		<programlisting language="javascript">
<xi:include href="samples/identity_fault.json" parse="text"/>
</programlisting>
	  </example>
	  <para>The error code is returned in the body of the response. The
			message section returns a human-readable message. The
			details section is optional and may contain useful
			information for tracking down an error. For example, a
			stack trace may be provided. </para>
	  <para>The root element of the fault may change depending on the
			type of error. The following is an example of an
			itemNotFound error. </para>
	  <example>
		<title>Item Not Found Fault: XML</title>
		<programlisting language="xml">
<xi:include href="samples/item_not_found.xml" parse="text"/>
</programlisting>
	  </example>
	  <example>
		<title>Item Not Found Fault: JSON</title>
		<programlisting language="javascript">
<xi:include href="samples/item_not_found.json" parse="text"/>
</programlisting>
	  </example>
	  <para> The following is a list of possible fault types along with their associated error
		codes. </para>
	  <table rules="all">
		<caption>Fault Types</caption>
		<thead>
		  <tr>
			<td>Fault Element</td>
			<td>Associated Error Codes</td>
			<td>Expected in All Requests</td>
		  </tr>
		</thead>
		<tbody>
		  <tr align="left">
			<td>identityFault</td>
			<td>500, 400</td>
			<td> &CHECK; </td>
		  </tr>
			<tr align="left">
			<td>serviceUnavailable</td>
			<td>503</td>
			<td> &CHECK; </td>
		  </tr>
			<tr align="left">
			<td>badRequest</td>
			<td>400</td>
			<td> &CHECK; </td>
		  </tr>         
			<tr align="left">
			<td>unauthorized</td>
			<td>401</td>
			<td> &CHECK; </td>
		  </tr>
			<tr align="left">
			<td>overLimit</td>
			<td>413</td>
			<td/>
		  </tr>
			<tr align="left">
			<td>userDisabled</td>
			<td>403</td>
			<td/>
		  </tr>
			<tr align="left">
			<td>forbidden</td>
			<td>403</td>
			<td/>
		  </tr>
			<tr align="left">
			<td>itemNotFound</td>
			<td>404</td>
			<td/>
		  </tr>
			<tr align="left">
			<td>tenantConflict</td>
			<td>409</td>
			<td/>
		  </tr>
		</tbody>
	  </table>
	  <para>From an XML schema perspective, all API faults are extensions
			of the base fault type, <type>identityFault</type>. When
			working with a system that binds XML to actual classes,
			use <type>identityFault</type> as a catch-all if there is
			no interest in distinguishing between individual fault
			types; for example, you may need to do this if you are
			working with JAXB. </para>
	</section>
    </chapter>
